import copydetect
from copydetect import *
from github import Github
import random
import os
import requests
import string
import json
import base64

# Code written by sankalpa 
def match_line(raw_code, slices):
    code_lines = []
    for i in range(slices[0].shape[0]):
        doc = raw_code
        start_line = doc.count('\n', 0, slices[0][i]) + 1
        end_line = doc.count('\n', 0, slices[1][i]) + 1
        code_lines.append([start_line, end_line])
    return code_lines


class CodeDetector:
    def __init__(self, repo_url, reponame) -> None:
        """"
        repo: Repo Object Provided by Github module 
        """
        self.repo_url = repo_url
        self.reponame = reponame
        self.extensions = {}
        self.files = []
        self.local_files = []
        self.path_url = {}    

    def get_sha_url(self):
        pat = ""
        headers = {'Authorization': f'token {pat}'}
        branch =  'master'
        sha = requests.get(f'https://api.github.com/repos/{self.repo_url}/git/refs/heads/master',headers=headers)
        if sha.status_code!=200:
            sha = requests.get(f'https://api.github.com/repos/{self.repo_url}/git/refs/heads/main',headers=headers)
            branch = 'main'
        sha = json.loads(sha.text)
        sha = sha.get('object').get('sha')
        sha_url = f'https://api.github.com/repos/{self.repo_url}/git/trees/{sha}?recursive=1'
        return sha_url,headers,branch
    
    def get_repo_files(self):
        """"
        return:
            match_extension: extension of files in repo -> set
            repo_files_path: files name/path in repo    -> dict
        """
        sha_url,headers,branch = self.get_sha_url()
        response = requests.get(sha_url,headers=headers)
        data = json.loads(response.text)
        file_info = {}
        language_extension = [".py", ".java", ".c", ".cpp", ".js", ".html", ".css", ".php", ".rb", ".go", ".swift", ".kt", ".scala", ".lua", ".pl", ".sh", ".m", ".sql", ".r",".jsx"]
        for item in data['tree']:
            if item['type'] == 'blob':
                filename = item['path']
                _, extension = os.path.splitext(filename)
                if extension in language_extension:
                    self.files.append(filename)
                    self.path_url[_+extension] = item.get('url')
                    extension = extension[1:]
                    if extension in file_info:
                        file_info[extension].append(filename)
                    else:
                        file_info[extension] = [filename]
        self.extensions = set(file_info.keys())
        return self.extensions,file_info,branch

    @classmethod
    def get_similar_extension(cls, o1, o2):
        """"
        o1: CodeDetector object1
        o2: CodeDetector object2

        return: Provides intersection bewteen two repo files extension -> Set

        """
        ignore_extension = ['jpg', 'jpeg', 'png', 'gif','xml','txt','.pptx','docx', 'bmp', 'tiff', 'webp',
                   'mp4', 'avi', 'mov', 'wmv', 'mkv', 'flv', 'webm',
                   'mp3', 'wav', 'ogg', 'flac', 'aac', 'wma','gitignore','md','txt']
        o1_extension = o1.extensions
        o2_extension = o2.extensions
        common_file_extension = o1_extension.intersection(o2_extension)
        for i in ignore_extension:
            if i in common_file_extension:
                common_file_extension.remove(i)
        return common_file_extension

    def download_files(self,filesinfo,common_extension):
        """
        common_extension: common extension between two repo files (generated by get_similar_extension)
        repo: Repo Object Provided by Github module
        self.reponame: string of repo folder ('repo1' or 'repo2')

        Return: 
            files_info: files name present in test/reponame -> dict
            files_mapper: dict contains filename of files name present in test/reponame folder : actual repo file name/path -> dict
        """
        files = filesinfo.get(self.repo_url)
        files_info = {self.reponame:{}}
        files_mapper = {self.reponame:{}}
        _,headers,__ = self.get_sha_url()
        for i in files:
            if i in common_extension:
                allfilenames = files.get(i)
                for j in allfilenames:
                    filename = os.path.basename(j)
                    f,current_extension = os.path.splitext(filename)
                    current_extension = current_extension[1:]
                    download_url = self.path_url.get(j)
                    content = requests.get(download_url,headers=headers)
                    file_content = content.json().get('content')
                    text = base64.b64decode(file_content).decode('utf-8')

                    if os.path.exists(f'./test/{self.reponame}/{filename}'):
                         random_string = '__' +''.join(random.choices(string.ascii_letters, k=5))
                         filename = f+random_string+'.'+current_extension
                    if (current_extension in files_info[self.reponame]):
                        files_info[self.reponame][current_extension].append(
                            filename)
                        files_mapper[self.reponame][filename] = j
                    else:
                        files_info[self.reponame][current_extension] = [filename]
                        files_mapper[self.reponame][filename] = j

                    self.local_files.append(filename)
                    with open(f'./test/{self.reponame}/{filename}', 'w') as f:
                        f.write(text)
        return files_info,files_mapper
                    

    @classmethod
    def similarities_checker(cls, files_info, common_file_extension, files_mapper,branches):
        final_output = []
        repo1_fingerprint = {}
        repo2_fingerprint = {}
        repo1 = files_info['repo1']
        repo2 = files_info['repo2']
        branch1 = branches['repo1'] 
        branch2 = branches['repo2']
        
        for i in common_file_extension:
            repo1_files = repo1[i]
            repo2_files = repo2[i]
            for j in repo1_files:
                for k in repo2_files:
                    
                    if j not in repo1_fingerprint:
                        repo1_fingerprint[j] = copydetect.CodeFingerprint(
                            f"./test/repo1/{j}", 25, 1)
                    if k not in repo2_fingerprint:
                        repo2_fingerprint[k] = copydetect.CodeFingerprint(
                            f"./test/repo2/{k}", 25, 1)

                    token_overlap, similarities, slices = copydetect.compare_files(
                        repo1_fingerprint[j], repo2_fingerprint[k])
                    if (similarities[0]!=0):
       
                        result = [
                            {
                                "filename": files_mapper['repo1'][j],
                                "percentage":int(similarities[0]*100),
                                "code_snippets":match_line(repo1_fingerprint[j].raw_code, slices[0]),
                                "branch":branch1
                            },
                            {
                                "filename": files_mapper['repo2'][k],
                                "percentage":int(similarities[1]*100),
                                "code_snippets":match_line(repo2_fingerprint[k].raw_code, slices[1]),
                                "branch":branch2
                            }
                        ]
                        final_output.append(result)
        total_files = len(list(repo1_fingerprint.keys()))+len(list(repo2_fingerprint.keys()))
        final_output.insert(0,[total_files])
        return final_output
    
    def delete_files(self):
        for filename in self.local_files:
            file_path = os.path.join(f'./test/{self.reponame}', filename)
            if os.path.isfile(file_path):
                os.remove(file_path)


